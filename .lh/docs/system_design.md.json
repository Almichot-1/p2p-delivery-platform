{
    "sourceFile": "docs/system_design.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1767975996783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767976166213,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,52 +1,79 @@\n # System Design (SDA)\r\n \r\n ## Architecture\r\n-- Client: Flutter app (UI → BLoC → Repository → Services) with GetIt DI and go_router routing.\r\n-- Backend: Firebase (Auth, Firestore) as primary data store; Cloudinary for image hosting.\r\n-- State: flutter_bloc + equatable; BLoCs own stream subscriptions and cancel on close.\r\n-- Single source of truth per domain:\r\n-  - trips/{id}, requests/{id}, matches/{id} in Firestore.\r\n-  - matches/{id} authoritative for agreement lifecycle once created.\r\n+- Client: Flutter app structured as UI → BLoC → Repository → Services, wired with go_router (navigation) and GetIt (DI).\r\n+- Backend: Firebase Auth + Firestore as primary store; Cloudinary for image hosting (unsigned uploads, preset-scoped).\r\n+- State: flutter_bloc + equatable; BLoCs own stream subscriptions and cancel on close; UI is passive.\r\n+- Data ownership: Firestore collections trips/{id}, requests/{id}, matches/{id}; matches/{id} is the source of truth for an agreement once created.\r\n+- Boundaries: UI never touches Firestore; repositories encapsulate schema + invariants; services keep external integrations isolated.\r\n \r\n ## Data Flow\r\n-- UI events dispatch to BLoCs → call repositories → repositories read/write Firestore (and Cloudinary for uploads).\r\n-- Reads: Firestore streams mapped to models, sorted client-side.\r\n-- Writes: Repositories validate, set server timestamps, and enforce business rules.\r\n-- Match creation: one transaction writes matches/{matchId} and updates requests/{requestId} to matched.\r\n+- Reads: Firestore streams → repositories map to models → BLoCs emit states → UI renders; client-side sorting (by departure/creation time) and lightweight filtering.\r\n+- Writes: BLoC intent → repository validates (auth, capacity, status, time) → Firestore write/transaction → BLoC emits success/error; server timestamps used for auditability.\r\n+- Concurrency: Firestore transactions serialize conflicting writes; deterministic IDs prevent duplicate matches from concurrent taps.\r\n \r\n-## Key Models\r\n+## Component Responsibilities\r\n+- UI layer: display lists/detail, gather intents, show validation or error banners, confirm dialogs before destructive/committal actions.\r\n+- BLoCs: orchestrate flows, guard duplicate submissions (intermediate `MatchCreating`), manage streams, expose typed states.\r\n+- Repositories: derive IDs, enforce business rules, perform Firestore queries and transactions, map to domain models.\r\n+- Services: Cloudinary upload (unsigned preset), Auth helper for uid + profile fields.\r\n+\r\n+## Sequences (key flows)\r\n+- Create Match (from trip or request):\r\n+  1) UI shows confirmation → dispatch `MatchCreateRequested`.\r\n+  2) BLoC emits `MatchCreating` to disable UI and prevent double taps.\r\n+  3) Repository: validate trip/request active, capacity sufficient, trip date in future, requester != traveler; call `matchExists`; start transaction → write matches/{matchId} + update requests/{requestId} status to matched + set matchedTripId/matchedTravelerId.\r\n+  4) BLoC emits `MatchCreated`; UI navigates or shows toast. Errors propagate with specific messaging (duplicate, inactive, capacity, same user, past trip).\r\n+- Listing (trips/requests): Firestore stream subscription → mapped models → BLoC state; UI sorts and filters by status and destination city.\r\n+\r\n+## Data Model Notes\r\n - TripModel: traveler info, origin/destination, departureDate, availableCapacityKg, pricePerKg, status, matchCount.\r\n - RequestModel: requester info, item details, weight, pickup/delivery, price, urgency, status, matchedTripId, matchedTravelerId, images.\r\n - MatchModel: tripId, requestId, traveler/requester info, itemTitle, route, tripDate, agreedPrice, status, participants, timestamps.\r\n+- Deterministic IDs: `${tripId}__${requestId}` enabling idempotent creation and O(1) lookup for a pair.\r\n \r\n ## Matching Logic (Phase 6.5)\r\n-- Deterministic matchId: \"${tripId}__${requestId}\" to guarantee one match per pair.\r\n-- Repository guard: `matchExists(tripId, requestId)` + transaction prevents duplicates.\r\n-- Traveler flow (Trip → Matching Requests):\r\n-  - Filters: request.deliveryCity == trip.destinationCity; request.status == active; request.weightKg ≤ trip.availableCapacityKg; trip must be active and upcoming.\r\n-  - Action: confirm dialog → `MatchCreateRequested` → creates match (status pending) → request becomes matched.\r\n-- Requester flow (Request → Matching Trips):\r\n-  - Filters: trip.destinationCity == request.deliveryCity; trip.status == active; trip upcoming; trip.availableCapacityKg ≥ request.weightKg.\r\n-  - Action: confirm dialog → `MatchCreateRequested` → creates match (status pending) → request becomes matched.\r\n-- Edge handling: errors surfaced for duplicate, inactive trip/request, capacity insufficient, trip date passed, same user on both sides.\r\n+- Repository guard: `matchExists(tripId, requestId)` + transaction prevents duplicates and races.\r\n+- Traveler flow (Trip → Matching Requests): filter request.deliveryCity == trip.destinationCity; request.status == active; request.weightKg ≤ trip.availableCapacityKg; trip active and upcoming.\r\n+- Requester flow (Request → Matching Trips): filter trip.destinationCity == request.deliveryCity; trip.status == active; trip upcoming; availableCapacityKg ≥ request.weightKg.\r\n+- Edge handling: duplicate attempts, inactive trip/request, insufficient capacity, trip date passed, same user on both sides → surfaced as typed errors.\r\n+- Integrity: matches drive the only path to set a request to matched; cancellations are status changes (no hard deletes), preserving auditability.\r\n \r\n ## Status Lifecycles\r\n - TripStatus: active → completed/cancelled.\r\n - RequestStatus: active → matched → inProgress/… (legacy) → completed/cancelled; matchedTripId/matchedTravelerId set on match creation.\r\n - MatchStatus: pending → accepted/rejected → confirmed → pickedUp → inTransit → delivered → completed; cancel allowed until delivered.\r\n+- Invariants: one request bound to one trip at a time; capacity checked at creation time (no decrement yet); status transitions validated in repository.\r\n \r\n-## Security/Posture (current)\r\n-- Firestore rules currently open (test mode until 2026-02-05); must be hardened: auth required; per-document ownership checks; matches readable by participants only.\r\n-- Cloudinary uploads are unsigned; preset abuse possible; acceptable for MVP only.\r\n+## Security/Posture (current and gaps)\r\n+- Firestore rules: open/test mode until 2026-02-05. Must tighten to: auth required; per-document ownership checks on trips/requests; matches readable/writeable only by participants; status transitions whitelist.\r\n+- Cloudinary: unsigned uploads allow preset abuse; mitigate with size/format limits and monitor usage; move to signed uploads later.\r\n+- PII minimization: match docs contain participant names/phones; restrict reads to participants; avoid copying more than needed.\r\n+- Abuse risks: spam match creation, rule bypass. Mitigations: client-side rate limits, server-side validation (future callable functions), audit logging.\r\n \r\n ## Performance & Offline\r\n-- Streams are small (per-user) and sorted client-side; no heavy composite indexes required for current filters.\r\n-- Offline not targeted; Firestore default caching applies.\r\n+- Scale expectation: tens to low hundreds of docs per user; client-side sorting is sufficient; no heavy indexes required yet.\r\n+- Potential index: destinationCity + status for trip/request matching lists if volume grows.\r\n+- Offline: Firestore cache provides basic offline reads; writes rely on connectivity; no bespoke offline queueing.\r\n \r\n+## Observability\r\n+- Client: BlocObserver for state/error logging; Flutter global error handler for crash breadcrumbs.\r\n+- Backend: none native to Firestore; consider Cloud Functions front-door for critical writes to centralize validation + logging + metrics.\r\n+- Metrics to watch: match creation failure rate by reason, time-to-match, cancellation rate pre- vs post-confirmation.\r\n+\r\n ## Build/Deploy\r\n - Local builds: `flutter build apk --debug`; install via ADB.\r\n-- Stale build fix: `flutter clean`; delete android/.gradle, android/build, android/app/build, build, .dart_tool; rebuild.\r\n+- Stale build remediation: `flutter clean`; delete android/.gradle, android/build, android/app/build, build, .dart_tool; rebuild.\r\n+- Release hygiene: analyzer clean; smoke tests for match flows; verify route table and DI registrations for new screens.\r\n \r\n ## Testing/Validation\r\n-- `flutter analyze` required to pass.\r\n-- Manual flows: trip/request creation; match creation from both sides; status transitions guarded in repository.\r\n+- Mandatory: `flutter analyze` clean.\r\n+- Happy paths: trip creation, request creation, match creation from both sides, pending → accepted flow (where implemented).\r\n+- Negative cases: duplicate match attempt blocked; capacity underflow blocked; creating match on past trip blocked; requester == traveler blocked; inactive trip/request blocked.\r\n+\r\n+## Future Enhancements (priority)\r\n+- Harden Firestore rules (owner/participant gating, status transition checks, write shape validation).\r\n+- Move match creation to callable Cloud Function for centralized validation, rate limiting, and audit logging.\r\n+- Capacity management on acceptance/rejection; rollback to active on rejection.\r\n+- Notifications (FCM) for match events (created/accepted/rejected).\r\n+- Pagination and server-side query filters when volume grows.\r\n"
                }
            ],
            "date": 1767975996783,
            "name": "Commit-0",
            "content": "# System Design (SDA)\r\n\r\n## Architecture\r\n- Client: Flutter app (UI → BLoC → Repository → Services) with GetIt DI and go_router routing.\r\n- Backend: Firebase (Auth, Firestore) as primary data store; Cloudinary for image hosting.\r\n- State: flutter_bloc + equatable; BLoCs own stream subscriptions and cancel on close.\r\n- Single source of truth per domain:\r\n  - trips/{id}, requests/{id}, matches/{id} in Firestore.\r\n  - matches/{id} authoritative for agreement lifecycle once created.\r\n\r\n## Data Flow\r\n- UI events dispatch to BLoCs → call repositories → repositories read/write Firestore (and Cloudinary for uploads).\r\n- Reads: Firestore streams mapped to models, sorted client-side.\r\n- Writes: Repositories validate, set server timestamps, and enforce business rules.\r\n- Match creation: one transaction writes matches/{matchId} and updates requests/{requestId} to matched.\r\n\r\n## Key Models\r\n- TripModel: traveler info, origin/destination, departureDate, availableCapacityKg, pricePerKg, status, matchCount.\r\n- RequestModel: requester info, item details, weight, pickup/delivery, price, urgency, status, matchedTripId, matchedTravelerId, images.\r\n- MatchModel: tripId, requestId, traveler/requester info, itemTitle, route, tripDate, agreedPrice, status, participants, timestamps.\r\n\r\n## Matching Logic (Phase 6.5)\r\n- Deterministic matchId: \"${tripId}__${requestId}\" to guarantee one match per pair.\r\n- Repository guard: `matchExists(tripId, requestId)` + transaction prevents duplicates.\r\n- Traveler flow (Trip → Matching Requests):\r\n  - Filters: request.deliveryCity == trip.destinationCity; request.status == active; request.weightKg ≤ trip.availableCapacityKg; trip must be active and upcoming.\r\n  - Action: confirm dialog → `MatchCreateRequested` → creates match (status pending) → request becomes matched.\r\n- Requester flow (Request → Matching Trips):\r\n  - Filters: trip.destinationCity == request.deliveryCity; trip.status == active; trip upcoming; trip.availableCapacityKg ≥ request.weightKg.\r\n  - Action: confirm dialog → `MatchCreateRequested` → creates match (status pending) → request becomes matched.\r\n- Edge handling: errors surfaced for duplicate, inactive trip/request, capacity insufficient, trip date passed, same user on both sides.\r\n\r\n## Status Lifecycles\r\n- TripStatus: active → completed/cancelled.\r\n- RequestStatus: active → matched → inProgress/… (legacy) → completed/cancelled; matchedTripId/matchedTravelerId set on match creation.\r\n- MatchStatus: pending → accepted/rejected → confirmed → pickedUp → inTransit → delivered → completed; cancel allowed until delivered.\r\n\r\n## Security/Posture (current)\r\n- Firestore rules currently open (test mode until 2026-02-05); must be hardened: auth required; per-document ownership checks; matches readable by participants only.\r\n- Cloudinary uploads are unsigned; preset abuse possible; acceptable for MVP only.\r\n\r\n## Performance & Offline\r\n- Streams are small (per-user) and sorted client-side; no heavy composite indexes required for current filters.\r\n- Offline not targeted; Firestore default caching applies.\r\n\r\n## Build/Deploy\r\n- Local builds: `flutter build apk --debug`; install via ADB.\r\n- Stale build fix: `flutter clean`; delete android/.gradle, android/build, android/app/build, build, .dart_tool; rebuild.\r\n\r\n## Testing/Validation\r\n- `flutter analyze` required to pass.\r\n- Manual flows: trip/request creation; match creation from both sides; status transitions guarded in repository.\r\n"
        }
    ]
}